Cleon Tan De Xuan (A0252030B)

Unit Test Approach

I was responsible for writing test cases for the Product, Payment, and General UI components features. This included unit tests for both frontend and backend components, specifically targeting untested critical areas of the application.

For all tests, the Arrange, Act, and Assert (AAA) pattern was primarily employed. The first section arranged the test setup by creating required object instances and mocking dependencies. The second section executed the production code being tested. The final section verified the results against expected outcomes.

Unit tests were crafted with careful consideration of the four pillars of good unit testing: protection against regressions, resistance to refactoring, fast feedback, and maintainability.

In backend tests, I applied Equivalence Partitioning (EP) and Boundary Value Analysis (BVA) strategies to ensure comprehensive coverage. For instance, in productModel.test.js, BVA was used to test price boundaries (0 for free items, 999999.99 for luxury items) and quantity extremes (0 for out-of-stock, 100000 for wholesale). EP was applied in orderModel.test.js to verify all valid status enum values ('Not Process', 'Processing', 'Shipped', 'deliverd', 'cancel'), ensuring the model correctly handles each state transition.

For frontend tests, I utilized three testing styles to maximize coverage:
- Output-based testing: Verifying rendered content matches expected UI states
- State-based testing: Checking component state changes in response to user actions  
- Communication-based testing: Ensuring correct API calls and navigation behavior

Mocking was extensively used to isolate units under test. Complex dependencies like Layout, Header, Footer, and routing components were mocked to keep tests fast and focused. Global contexts (auth, cart, search) were stubbed to simulate various application states without requiring the full provider stack, improving both test speed and resistance to refactoring.

Test Statistics

Backend Unit Tests:
• Test suites created: 2
• Total unit tests written: 21
• Files tested:
  - models/productModel.test.js (10 tests)
  - models/orderModel.test.js (11 tests)

Frontend Unit Tests:
• Test suites created: 5
• Total unit tests written: 55
• Files tested:
  - pages/ProductDetails.test.js (11 tests)
  - pages/CategoryProduct.test.js (9 tests)
  - components/Header.test.js (17 tests)
  - components/Layout.test.js (11 tests)
  - components/AdminMenu.test.js (7 tests)

Overall Statistics:
• Total test suites: 7
• Total unit tests: 76
• Test execution: All tests passed
• Code coverage: 100% for tested backend models

Testing Coverage by Feature:

1. Product Feature (Backend)
   - productModel: Validated all required fields, optional fields (photo, shipping), boundary values for price and quantity, and schema integrity
   - Covered critical business logic for product creation and validation

2. Order Feature (Backend)  
   - orderModel: Tested order creation with single/multiple products, default status values, all enum status transitions, and empty edge cases
   - Ensured order lifecycle state management works correctly

3. Product Pages (Frontend)
   - ProductDetails: Tested product display, price formatting, image rendering, API integration, related products section, navigation, and error handling
   - CategoryProduct: Validated category filtering, product listing, count display, description truncation, navigation, and API error resilience

4. General UI Components (Frontend)
   - Header: Comprehensive testing of authentication states (guest, user, admin), navigation links, logout functionality, cart badge display, and category dropdown
   - Layout: Verified component composition, Helmet integration, Toaster placement, custom prop handling, and structural hierarchy
   - AdminMenu: Tested all admin navigation links, correct routing, and menu structure

Key Testing Achievements:

1. Filled Critical Gaps: Targeted completely untested models (productModel, orderModel) and core UI components (Header, Layout, AdminMenu) that are foundational to the application

2. Comprehensive Boundary Testing: Applied BVA to numeric fields (price: $0 to $999,999; quantity: 0 to 100,000) ensuring edge cases are handled gracefully

3. State Coverage: Tested all order status enum values and authentication states (unauthenticated, regular user, admin) to verify correct application behavior across scenarios

4. Error Resilience: Included error handling tests for API failures and malformed data, improving application robustness

5. User Interaction Flows: Validated complete user journeys including product browsing, navigation between pages, and logout workflows

The test suite provides strong protection against regressions while maintaining good resistance to refactoring through strategic use of mocks and focus on behavior over implementation details.


Cleon Tan De Xuan, A0252030B
